OVERVIEW
========

JPSX is built entirely of pluggable components. If you look at jpsx.xml, you'll see the default definitons that I use.
The XML format is just a convenience; This is parsed into a MachineDefintion internally (see MachineDefinition.java)

Although any part of the emulator can be replaced, it makes less sense to do so with some parts than others; I have three main groupings:

core - internal stuff like address space (that you probably don't want to swap out)
hardware - implementations of emulated hardware that you might want to swap out
emulator - implementations of emulator components such as the cross-compiler

While the emu doesn't force any particular interfaces on the implementation, obviously for different pieces of the emulator
to work together they have to know how to talk to eachother. This is done by named connections (basically an interface), and
these happen to live in the API tree.

An example connection is Display which is used by the software GPU. The Display implementation provides an int[] for the GPU to draw into,
and the Display is simply responsible for displaying the correct portion of VRAM to the user when told to (There is also a DisplayManager 
which tracks info about what part of the VRAM should be displayed). At some point in the future it will probably make
sense to split the GPU into two parts, one doing decode of commands and the other just doing the rendering... the API
between them would probably be similar to traditions PSX GPU plugins.


BUILDING THE EMU
================

"ant" should do it.

RUNNING THE EMU
===============

VERY IMPORTANT: As I mentioned on the thread, the biggest problem right now on some platforms is the copy up as done by the Display
implementation. This SHOULD be very quick, but isn't on all platforms, and the emu will appear to suck if this is too slow. Because
of this I added a blit time to the title bar of the default display... if you aren't getting <2ms then things are probably not good.

Windows XP - any JDK5 or JDK6 is fine. Blit should be quick, if not try adding -Dsun.java2d.ddscale=true to your command line

Vista - Aero's Direct X changes caused Java to have to disable all hardware acceleration. This is now fixed in the latest preview
release of JDK6... To run (well) on Vista, you MUST use this VM (https://jdk6.dev.java.net/6u10ea.html). Note this release
also supports using OpenGL on some platforms

OS X - this is the beast right now (I'm hoping someone will add a JNI implementation of Display - or a JOGL one).
You can definitely try -Dapple.awt.graphics.UseQuartz=true and see how you do, otherwise (and this doesn't look as good, but at least it'll
run fast, you can do ./r.sh nostretch (r.sh being your shell script to run) which will use the machine defined in jpsx.xml which 
configures the display to not do a stretch blit - I just put this in the other day

Linux - haven't tried it recently.

If you are unsure if you're getting acceleration try -Dsun.java2d.trace=log, if use see a lot of java2d.loops stuff that is unnaccelerated
(note if you are successfully using quartz on OS X then you won't see any logging)

COMMAND LINE (I included a bat file for windows, but for OSX it should look something like)
 
java -Xmx128M -XX:-DontCompileHugeMethods org.jpsx.bootstrap.JPSXLauncher $*

Note the DontCompileHugeMethods is important, since sometimes generated bytecode for a method is large (although I did add some
code later to split big functions), and by default HotSpot doesn't bother to compile methods that are too large.

Additional arguments are <machineId> to pick a specific machine, and any number of property=value

e.g. rnea image=/rips/gt.cue

will set the image property used by the CUE/BIN CD drive to a specific file (note I think right not that the CUE must
specify an absolute path to the BIN file).


KEYS
====

The default machine definition includes a "console" component... this is interactive sort of like gdb. So to get stuff to
run in this mode you need to enter "g" for go. You can look at the code for Console to figure out some other commands. "b" breaks for example

Look at AWTKeyboardController for the controller mappings

The display also supports a few keys (don't forget 'fn' on OS X).

F12 - resize (on Vista the display is sometimes off by a few pixels, hitting F12 back to the same original size fixes this)
F9 - toggle full VRAM display - this is kinda cool


GOOD LUCK; let me know what happens (note I mentioned the following games that I know work well)

Abe's Odyssey
Wipeout
Wipeout XL
Tekken
Crash Bandicoot (note you must use the "bandicoot" machine which turns on a fudge for root counters which aren't in there yet)
Gran Turismo (if you turn the sound off - against there is a "gt" machine)
Music CDs ;-)

I have tried Final Fantasy VII in the past which I think was OK... Tomb Raider is currently broken because one of the
CdlGetLocs is not done right - I wrote a C emu in the past, and had exactly the same problem... i should fix!
